## Authentication types
Có 3 loại chính:  
- **"KNOW"**: password, answer to security question  
- **"HAVE"**: physical object (mobile phone, security token)  
- **"ARE or DO"**: biometrics, behavior  

→ Cơ chế xác thực sẽ dựa vào nhiều công nghệ khác nhau để xác minh một hoặc nhiều các yếu tố trên.

---

## Authentication vulnerabilities arise
Hầu hết các lỗ hổng dạng này xảy ra bởi 2 trường hợp:  
- **Cơ chế yếu** do thực hiện không đầy đủ trước các cuộc tấn công brute force  
- **Logic flaws** hoặc **Poor coding** trong quá trình triển khai khiến attacker bỏ qua cơ chế xác thực (**Broken Authentication**)  

---

## Vulnerabilities in authentication mechanisms
Hệ thống xác thực của một website thường bao gồm nhiều cơ chế riêng biệt, và lỗ hổng có thể phát sinh tại bất kỳ cơ chế nào.  
- Một số lỗ hổng có thể xảy ra trên **toàn bộ ngữ cảnh liên quan đến xác thực**  
- Những lỗ hổng khác chỉ xuất hiện trong **các chức năng cụ thể** 
#### Các lĩnh vực phổ biến
- [[#Vulnerabilities in password-based login]] 
- **Vulnerabilities in multi-factor authentication**  
- **Vulnerabilities in other authentication mechanisms**  
#### Vulnerabilities in third-party authentication mechanism
#TODO OAuth authentication

---
## Vulnerabilities in password-based login
Trong hoàn cảnh này việc người dùng biết mật khẩu bí mật của tài khoản chính là minh chứng cho việc xác minh người dùng.

### Brute-force attacks
1. Brute-forcing usernames:
	- Usernames đặc biệt có thể đoán thông qua các mẫu như email (`firstname.lastname@somecompany.com`). Tuy nghiên trong những hoàn cảnh quy luật của mẫu không rõ ràng ta có thể đoán tên người dùng phổ biến ( carlos, wiener, admin, administrator,...)
	
	- Trong quá trình audit, check xem website có tiết lộ thông tin người dùng hay không hoặc kiểm tra các phản hồi để xem các email có đặc quyền cao.

2. Brute-forcing passwords

3. Username enumeration
	Việc Enumerate username có thể dựa vào các dấu hiệu trong phản hồi. Trong trang login thì một số dấu hiệu thường thấy là `Status Code`, `Error messages`,`Respones times`.
	Labs:
		[[Solution Authentications labs#Username enumeration via different responses|Username enumeration via different responses]]
		[[Solution Authentications labs#Username enumeration via subtly different responses|Username enumeration via subtly different responses]]
		[[Solution Authentications labs#Username enumeration via response timing|Username enumeration via response timing]]
	
### Flawed brute-force protection
Về logic, chống brute-force nhằm **làm chậm và khó tự động hóa tấn công**. Hai cách phổ biến: **Locking** và **Blocking** tài khoản. Cả 2 cách tiếp cận đều có thể gặp vấn đề nếu thực hiện logic sai lầm.

>Một số hệ thống chặn IP sau nhiều lần login sai, nhưng reset bộ đếm nếu login thành công. Kẻ tấn công có thể dùng tài khoản riêng login xen kẽ để né giới hạn này.

1. Account locking
	Website thường khóa tài khoản sau một số lần login sai để ngăn brute-force. Tuy nhiên, thông báo "account locked" lại có thể bị lợi dụng để enumerate username (xác định username tồn tại).
	**Hạn chế của account locking:**
	- **Không chặn brute-force toàn diện**:
	    - Nếu attacker không nhắm vào 1 tài khoản cụ thể, mà chỉ cần chiếm **bất kỳ tài khoản nào**, account locking trở nên kém hiệu quả.
	- **Bypass logic qua danh sách nhỏ mật khẩu**:
	    1. Attacker chuẩn bị một danh sách username (qua enumeration hoặc common list).
	    2. Chọn một số rất ít mật khẩu phổ biến (≤ số lần cho phép trước khi bị khóa).
	        - Ví dụ: nếu limit là 3 lần → attacker chọn 3 password phổ biến.
	    3. Dùng Burp Intruder để thử **mọi username** với **tối đa 3 password**.
	    4. Chỉ cần một người dùng có password trùng là attacker compromise thành công.
	- **Credential stuffing không bị chặn**:
	    - Credential stuffing = dùng dictionary chứa nhiều cặp username:password bị rò rỉ từ data breach
	    - Vì mỗi username chỉ thử **một lần**, account locking (theo số lần sai liên tiếp) không có tác dụng.

2. User rate limiting
	Tài khoản sẽ bị chặn trong 1 khoảng thời gian hoặc phải giải captcha hoặc được admin mở lại. Tuy nhiên có 1 số cách bypass như giả mạo proxy, thực hiện nhiều payload trong 1 request.
### HTTP basic authentication
- Dùng `username:password` mã hóa Base64, gửi trong header:```
    Authorization: Basic base64(username:password)```
- Không an toàn vì:
    - Gửi lại credential trong mọi request → dễ bị MITM nếu không có HSTS.
    - Ít khi có cơ chế chống brute-force.
    - Dễ bị tấn công session như **CSRF**.
- Credential thu được có thể bị tái sử dụng ở hệ thống khác.

---
